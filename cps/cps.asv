classdef (Abstract) cps < handle

    properties
        sub_systems = {}; % Cell array of sub_cps that make up this system
        A; B;
        control_systems = {}; % holds handles to each control_system
    end

    methods
        function self = cps()

        end % %init_parent_system

        function self = add_sub_system(self, new_sub_system)
            state_idx_start = length(self.A) + 1;
            cntrl_idx_start = length(self.B) + 1;

            self.sub_systems{end+1} = new_sub_system;
            
            % Assign state and control idxs
            [new_physical_states, ~] = size(new_sub_system.physical_system.A);
            [new_cyber_states, ~] = size(new_sub_system.cyber_system.A);
            [~, new_physical_controls] = size(new_sub_system.physical_system.B);
            [~, new_cyber_controls] = size(new_sub_system.cyber_system.B);


            % state indicies
            
            % physical states
            physical_state_idcs = state_idx_start:state_idx_start+new_physical_states-1; % location of this physical system's state in cps state vector
            self.sub_systems{end}.cps_xpidcs = physical_state_idcs;

            self.control_systems{end+1} = new_sub_system.physical_system; % Add this control system to 'self.control_systems'
            self.control_systems{end}.cps_state_idcs = physical_state_idcs; % location of this control system's state in cps state vector (as property of the control system) (redundant)
            self.sub_systems{end}.physical_system.cps_cntrl_idx = length(self.control_systems); % location of this control system in 'self.control_systems'
    
            % cyber states
            new_idx_start = state_idx_start+new_physical_states;
            cyber_state_idcs = new_idx_start:new_idx_start+new_cyber_states-1; % location of this cyber'systems state in cps state vector
            self.sub_systems{end}.cps_xcidcs = cyber_state_idcs;
            
            %Assign the physical system update variable
            self.control_systems{end}.cps_update_idx = cyber_state_idcs(end); % the index of the cyber state variable that sets the physical system's update rate

            %helpful vector of handles to sub_system control systems
            self.control_systems{end+1} = new_sub_system.cyber_system;
            self.control_systems{end}.cps_state_idcs = cyber_state_idcs;

            self.control_systems{end}.cps_update_idx = cyber_state_idcs(end);
            self.sub_systems{end}.cyber_system.cps_cntrl_idx = length(self.control_systems); % location of this control system in 'self.control_systems'
    
            
            % control indicies
            self.sub_systems{end}.cps_upidcs = cntrl_idx_start:cntrl_idx_start+new_physical_controls-1;
            new_idx_start = cntrl_idx_start + new_physical_controls;
            self.sub_systems{end}.cps_ucidcs = new_idx_start:new_idx_start+new_cyber_controls-1;


            % build the new A,B matrices for the entire cps
            newA = [];
            newB = [];
            for i = 1:length(self.sub_systems)
                newA = blkdiag(newA, self.sub_systems{i}.physical_system.A);
                newA = blkdiag(newA, self.sub_systems{i}.cyber_system.A);

                newB = blkdiag(newB, self.sub_systems{i}.physical_system.B);
                newB = blkdiag(newB, self.sub_systems{i}.cyber_system.B);
            end
            
            self.A = newA;
            self.B = newB;
        end

        function xdot = systemfun(self,t,x,u)
            xdot = self.A*x + self.B*u;
        end

        function [trajectory] = simulate(self, sim_span)
            % The CPS is simulated by breaking the entire 'sim_span' into
            % smaller windows that end when the next control system within
            % the CPS needs to update its control input (cyber or physical)
            
            % 1) set the simulation window, check that it's valid 
            sim_end = sim_span(2);
            window_start = sim_span(1);
            if (sim_end < window_start) || (sim_end - window_start) < 0.005 || length(sim_span) ~= 2
                error("Invalid simulation window")
            end
            
            % 2) set the initial 'sampling_period' for the physical systems
            % based on the designated cyber state variable
            for i = 1:length(self.sub_systems)
                rate = self.sub_systems{i}.cyber_system.x0(2); % Assumption: the second state var of the cyber system represents the update rate Hz
                starting_period = 1/rate;
                self.sub_systems{i}.physical_system.update_sampling_period(starting_period);
            end
            
            %3) initialize the 'next_update' vector that holds the update
            %schedule for each control system
            number_of_control_systems = length(self.control_systems);
            next_update = zeros(number_of_control_systems,1);
            for i = 1:length(self.control_systems)
                next_control_update = window_start + self.control_systems{i}.sampling_period;
                self.control_systems{i}.update_sampling_period(next_control_update);
                self.control_systems{i}.set_next_update(next_control_update)
                next_update(i) = next_control_update;
            end

            %4) Initialize CPS initial conditions
            x_sim = [];
            for i = 1:length(self.control_systems)
                new_x0 = self.control_systems{i}.x0;
                x_sim = [x_sim; new_x0];
            end
            

            %5) set other simulation variables
            t_sim = sim_span(1); % initial simulation time
            [~, number_of_inputs] = size(self.B);
            u_sim = zeros(1,number_of_inputs); %control input history
            u = zeros(number_of_inputs,1); %control input vector (not the history)
            update_switch = ones(1,number_of_inputs); %logical vector that indicates if a control system should be updated

            %6) simulate CPS through the windows
            while (sim_end > window_start)
            
                %6.1) set the window for this segment of the simulation
                [window_end, ~] = min(next_update);
                window_span = window_start:0.001:window_end;

                %6.2) set the control inputs based on the update switch
                for i = 1:length(self.control_systems) 
                    if update_switch(i) == 1
                        %calculate the new control input
                        idcs = self.control_systems{i}.cps_state_idcs; %indicies of this control system's state(s)
                        working_x = x_sim(idcs,end);
                        u(i) = self.control_systems{i}.systeminput(t_sim(end), working_x);
                        %track the new update and time it occured
                        self.control_systems{i}.input_updates(:,end+1) = zeros(length(u(i))+1,1);
                        self.control_systems{i}.input_updates(1,end) = t_sim(end);
                        self.control_systems{i}.input_updates(2:end,end) = u(i);

                    end
                end
                
                %6.3) reset update switch
                update_switch = 0*update_switch; 

                %6.4) simulate the system through the window
                [t_window, x_window] = ode45( @(t_sim, x_sim) self.systemfun(t_sim,x_sim,u), window_span, x_sim(:,end));
                
                %6.5) update the history vectors
                x_sim = [x_sim x_window'];
                t_sim = [t_sim t_window'];
                
                %6.6) the control inputs are zoh's, buid their 'history'
                u_window = -1*ones(length(t_window), number_of_inputs);
                for i = 1:number_of_inputs
                    u_window(:,i) = u(i)*u_window(:,i);
                end
                u_sim = [u_sim; u_window];

                %6.7) Update sampling rates, schedule next updates, set update
                % switch as needed (up to 0.005 s out)
                for i = 1:length(self.sub_systems)

                    if ( (self.sub_systems{i}.physical_system.next_update - t_sim(end) ) <= 0.005)
                        rate_idx = self.sub_systems{i}.physical_system.cps_update_idx;
                        new_rate = x_sim(rate_idx, end);
                        new_period = 1 / new_rate;
                        self.sub_systems{i}.physical_system.update_sampling_period(new_period);

                        switch_idx = self.sub_systems{i}.physical_system.cps_cntrl_idx;
                        update_switch(switch_idx) = 1;
                        
                        next_update = self.sub_systems{i}.physical_system.next_update + self.sub_systems{i}.physical_system.sampling_period;
                        self.sub_systems{i}.physical_system.set_next_update(next_update)
                    end

                    if ( (self.sub_systems{i}.cyber_system.next_update - t_sim(end) ) <= 0.005)
                        
                        % CPS coupling
                        physical_system_state = x_sim(self.sub_systems{i}.cps_xpidcs,end);
                        new_rate_target = norm(physical_system_state);

                        % old coupling
                        % state_idx = self.sub_systems{i}.cps_xpidcs(1);
                        % new_rate_target = 2 * x_sim(state_idx,end);

                        self.sub_systems{i}.cyber_system.update_velocity_reference(new_rate_target);
                        % CPS coupling end

                        switch_idx = self.sub_systems{i}.cyber_system.cps_cntrl_idx;
                        update_switch(switch_idx) = 1;

                        next_update = self.sub_systems{i}.cyber_system.next_update + self.sub_systems{i}.cyber_system.sampling_period;
                        self.sub_systems{i}.cyber_system.set_next_update(next_update)
                    end

                end
                
                %6.8) refresh 'next_update' vector
                for i = 1:length(self.control_systems)
                    next_update(i) = self.control_systems{i}.next_update;
                end
                
                %6.9) set the nexxt window start
                window_start = t_window(end)
            end %6)

        trajectory = [x_sim', u_sim, t_sim'];
        end %simulate
    end % methods
end % CPS classdef